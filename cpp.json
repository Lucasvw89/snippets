{
    "comp": {
        "prefix": "comp",
        "body": [
            "#ifdef ONPC",
            "    #define _GLIBCXX_DEBUG",
            "#endif",
            "",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define ll long long",
            "#define ld long double",
            "#define vec vector",
            "#define ii pair<int,int>",
            "",
            "#define all(a) a.begin(), a.end()",
            "",
            "#define FOR(a,b,c) for(int a = (b); a != (c); (a < (c) ? a++ : a--))",
            "",
            "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "",
            "",
            "int32_t main() {",
            "    ios::sync_with_stdio(0);",
            "    cin.tie(0);",
            "",
            "    $0",
            "",
            "    return 0;",
            "}"
        ],
        "description": "comp snippet"
    },
    "t_times": {
        "prefix": "tt",
        "body": [
            "int cases; cin >> cases;",
            "while (cases--) {",
            "    $0",
            "}"
        ],
        "description": "binary search"
    },
    "bin_search": {
        "prefix": "bins",
        "body": [
            "// array is ${1:arr} || target is ${2:target}",
            "int bl = 0, br = $1.size() - 1;",
            "int bmid;",
            "while (bl <= br) {",
            "    bmid = bl + ((br - bl) >> 1);",
            "    if ($2 == $1[bmid]) { break; }",
            "    else if ($2 < $1[bmid]) br = bmid - 1;",
            "    else bl = bmid + 1;",
            "}"
        ],
        "description": "binary search"
    },
    "dsu" :{
        "prefix": "DSU",
        "body": [
            "struct DSU {",
            "    int n;",
            "    vector<int> p, sz;",
            "",
            "    DSU(int n) : n(n), p(n), sz(n, 1) {",
            "        iota(p.begin(), p.end(), 0);",
            "    }",
            "",
            "    int find(int x) {",
            "        if (x == p[x]) return x;",
            "        return x = find(p[x]);",
            "    }",
            "",
            "    bool unite(int a, int b) {",
            "        a = find(a);",
            "        b = find(b);",
            "        if (a == b) return false;",
            "        if (sz[a] < sz[b]) swap(a, b);",
            "        p[b] = a;",
            "        sz[a] += sz[b];",
            "        return true;",
            "    }",
            "};"
        ],
        "description": "dsu impl"
    },
    "primes": {
        "prefix": "primes",
        "body": [
            "int ${1:x} = 1e7 + 10;",
            "vec<bool> is_prime($1,true);",
            "is_prime[0] = is_prime[1] = false;",
            "for (int _1 = 2; _1*_1 <= $1; _1++) {",
            "    if (is_prime[_1]) {",
            "        for (int _2 = _1*_1; _2 <= $1; _2+=_1) is_prime[_2] = false;",
            "    }",
            "}",
            "vec<ll> primes;",
            "FOR(i,2,x) {",
            "    if (is_prime[i]) primes.push_back(i);",
            "}"
        ],
        "description": "sieve of eratosthenes"
    },
    "PolygonAreaFunction": {
        "prefix": "polyarea",
        "body": [
        "ld area(const vector<point> &P) {",
        "    ld result = 0.0, x1, y1, x2, y2;",
        "    for (int i = 0; i < (int)P.size() - 1; i++) {",
        "        x1 = P[i].x; x2 = P[i+1].x;",
        "        y1 = P[i].y; y2 = P[i+1].y;",
        "        result += (x1 * y2 - x2 * y1);",
        "    }",
        "    return fabsl(result) / 2.0;",
        "}"
        ],
        "description": "compute polygon area"
    },
    "IsConvex": {
        "prefix": "isconvex",
        "body": [
            "bool is_convex(const vector<point> &P) {",
            "    int sz = (int)P.size();",
            "    if (sz <= 3) return false;",
            "    bool isLeft = ccw(P[0], P[1], P[2]);",
            "    for (int i = 1; i < sz - 1; i++)",
            "        if (ccw(P[i], P[i + 1], P[(i + 2 == sz) ? 1 : i + 2]) != isLeft)",
            "            return false;",
            "    return true;",
            "}"
        ],
        "description": "check polygon convexity"
    },
    "ccw": {
        "prefix": "ccw_snippet",
        "body": [
            "bool ccw(const point &a, const point &b, const point &c, bool accept_collinear) {",
            "    ll cross = (b.x - a.x) * 1LL * (c.y - a.y) - (b.y - a.y) * 1LL * (c.x - a.x);",
            "    return cross > 0 || (cross == 0 && accept_collinear);",
            "}"
        ],
        "description": "Boolean ccw with optional"
    },
	"InPolygonFunction": {
		"prefix": "inpoly",
		"body": [
			"bool in_polygon(point pt, const vector<point> &P) {",
			"    if (P.size() < 3) return false;",
			"    ld sum = 0;",
			"    int N = P.size();",
			"    for (int i = 0; i < N; i++) {",
			"        int next = (i + 1) % N;",
			"        if (ccw(pt, P[i], P[next]))",
			"            sum += angle(P[i], pt, P[next]);",
			"        else",
			"            sum -= angle(P[i], pt, P[next]);",
			"    }",
			"    return fabs(fabs(sum) - 2 * PI) < EPS;",
			"}"
		],
		"description": ""
	},
    "PointStruct": {
        "prefix": "ptstruct",
        "body": [
        "struct point {",
        "    double x, y;",
        "    bool operator == (point const& t) const {",
        "        return x == t.x && y == t.y;",
        "    }",
        "};"
        ],
        "description": ""
    }
} 
